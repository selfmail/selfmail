datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

// Authentication
model User {
    id       String @id @default(uuid())
    name     String
    password String
    email    String @unique

    // Two-factor authentication fields
    twoFactorEnabled Boolean @default(false)
    twoFactorSecret  String?
    backupCodes      String? // JSON array of hashed backup codes

    // a single user can be member of different workspaces
    member            Member[]
    EmailVerification EmailVerification[]
    Session           Session[]
    SmtpCredentials   SmtpCredentials[]
    Activity          Activity[]
    TwoFactorToken    TwoFactorToken[]

    @@unique([id, email])
}

model EmailVerification {
    id String @id @default(uuid())

    // the user that is being verified
    userId String
    user   User   @relation(fields: [userId, email], references: [id, email])

    email String

    // the verification token
    token String @unique

    // the date when the verification was created
    createdAt DateTime @default(now())

    @@unique([email, userId])
}

model Session {
    id String @id @default(uuid())

    // the user that is being verified
    userId String
    user   User   @relation(fields: [userId], references: [id])

    // the session token
    token String @unique

    // the date when the session was created
    createdAt DateTime @default(now())
}

model Member {
    id String @id @default(uuid())

    userId String
    user   User   @relation(fields: [userId], references: [id])

    // profile configuration
    profileName String? // by default it's the name of the user
    description String?
    image       String? // url to image (hosted on selfmail r2) or undefined for no image

    // permissions

    workspaceId      String
    workspace        Workspace          @relation(fields: [workspaceId], references: [id])
    MemberPermission MemberPermission[]
    MemberAddress    MemberAddress[]
    OutgoingEmail    OutgoingEmail[]
    roles            Role[]

    @@unique([workspaceId, userId])
    @@index([userId])
}

// permissions

// A role is just a set of editable permissions that can be assigned to users. These roles are editable
// by the owner of the workspace. The owner can create, update, and delete roles, and assign them to users.
model Role {
    id          String  @id @default(uuid())
    name        String
    description String?

    workspaceId    String
    workspace      Workspace        @relation(fields: [workspaceId], references: [id])
    member         Member[]
    RolePermission RolePermission[]
}

model RolePermission {
    roleId String
    role   Role   @relation(fields: [roleId], references: [id])

    permissionId String
    permission   Permission @relation(fields: [permissionId], references: [id])

    @@id([roleId, permissionId])
}

model MemberPermission {
    memberId String
    member   Member @relation(fields: [memberId], references: [id])

    permissionId String
    permission   Permission @relation(fields: [permissionId], references: [id])

    givenAt DateTime @default(now())

    @@id([memberId, permissionId])
}

// Permissions are the actual actions that a user can perform in a workspace. These permissions
// are not editable by the owner of the workspace, he can only assign them to roles and users.
model Permission {
    id          String  @id @default(uuid())
    name        String  @unique
    description String?

    RolePermission    RolePermission[]
    MemberPermissions MemberPermission[]
}

// Workspaces

model Workspace {
    id          String  @id @default(uuid())
    name        String
    description String?
    image       String? // url to image (hosted on selfmail r2) or undefined for no image

    slug            String            @unique @default(uuid())
    ownerId         String
    Member          Member[]
    Role            Role[]
    Domain          Domain[]
    SmtpCredentials SmtpCredentials[]
    Activity        Activity[]

    @@index([ownerId])
}

model Domain {
    id String @id @default(uuid())

    domain String @unique

    workspaceId String
    workspace   Workspace @relation(fields: [workspaceId], references: [id])

    verified   Boolean   @default(false)
    verifiedAt DateTime?

    // a verification token must be a txt record for the domain
    // it is used to verify that the user owns the domain
    verificationToken String
}

// addresses
model Address {
    id String @id @default(uuid())

    email String @unique

    // multiple members can access the same address (e.g. shared addresses)
    MemberAddress   MemberAddress[]
    Email           Email[]
    OutgoingEmail   OutgoingEmail[]
    SmtpCredentials SmtpCredentials[]
    Contact         Contact[]
}

model MemberAddress {
    memberId String
    member   Member @relation(fields: [memberId], references: [id])

    addressId String
    address   Address @relation(fields: [addressId], references: [id])

    @@id([memberId, addressId])
}

model Contact {
    id String @id @default(uuid())

    name        String?
    description String?
    image       String? // url to image (hosted on selfmail r2) or undefined

    blocked Boolean @default(false)

    addressId String
    address   Address @relation(fields: [addressId], references: [id])

    // Expecting addiotional information to be stored as JSON as the following schema:

    /**
     * (pretty weird formatting from vscode and prisma :/ )
     * [
     * {
     * "key": "phone",
     * "value": "+1234567890"
     * },
     * {
     * "key": "address",
     * "value": "123 Main St, Anytown, USA"
     * }
     * ]
     */
    additionalInformation Json[]

    email         String
    Email         Email[]
    OutgoingEmail OutgoingEmail[]

    @@unique([email, addressId])
}

model Email {
    id String @id @default(uuid())

    // email data
    subject     String
    body        String
    html        String?
    attachments String[] // array of attachment IDs

    // instead of referencing the address directly, we reference the contact
    contact   Contact @relation(fields: [contactId], references: [id])
    contactId String

    // the recipient of the email
    addressId String
    address   Address @relation(fields: [addressId], references: [id])

    date DateTime @default(now())
}

model OutgoingEmail {
    id String @id @default(uuid())

    // email data
    subject String
    body    String
    html    String?

    // the sender of the email
    addressId String
    address   Address @relation(fields: [addressId], references: [id])

    // the user which sent the email
    memberId String
    member   Member @relation(fields: [memberId], references: [id])

    // the recipient of the email
    contact   Contact @relation(fields: [contactId], references: [id])
    contactId String

    date DateTime @default(now())
}

model SmtpCredentials {
    id String @id @default(uuid())

    title       String
    description String?

    // actual credentials
    username String
    password String

    // created by the user
    userId String
    user   User   @relation(fields: [userId], references: [id])

    // the workspace this credentials are used for
    workspaceId String
    workspace   Workspace @relation(fields: [workspaceId], references: [id])

    // the address of the crendentials
    addressId String
    address   Address @relation(fields: [addressId], references: [id])

    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
    activeUntil DateTime?

    @@unique([username, password])
}

// Activity Log
model Activity {
    id String @id @default(uuid())

    title       String
    description String?
    color       ActivityColor
    type        ActivityType

    // Relations
    workspaceId String
    workspace   Workspace @relation(fields: [workspaceId], references: [id])

    userId String?
    user   User?   @relation(fields: [userId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([workspaceId])
    @@index([userId])
    @@index([createdAt])
    @@index([type])
}

enum ActivityColor {
    neutral
    positive
    negative
}

enum ActivityType {
    task
    note
    event
    reminder
}

// Two-Factor Authentication
model TwoFactorToken {
    id        String   @id @default(uuid())
    token     String   @unique
    userId    String
    user      User     @relation(fields: [userId], references: [id])
    createdAt DateTime @default(now())
    expiresAt DateTime

    @@index([userId])
    @@index([token])
}
