datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

// Admin models
model AdminUser {
  id            String         @id
  name          String
  email         String
  emailVerified Boolean        @default(false)
  image         String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @default(now()) @updatedAt
  sessions      AdminSession[]
  accounts      AdminAccount[]

  @@unique([email])
  @@map("user")
}

model AdminSession {
  id        String    @id
  expiresAt DateTime
  token     String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model AdminAccount {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model AdminVerification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

// Authentication
model User {
  id       String @id @default(uuid())
  name     String
  password String
  email    String @unique

  workspaceLimit Int @default(3) // max number of workspaces a user can create, contact support to increase

  // Two-factor authentication fields
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret  String?
  backupCodes      String? // JSON array of hashed backup codes

  emailVerified DateTime?

  // a single user can be member of different workspaces
  member            Member[]
  EmailVerification EmailVerification[]
  Session           Session[]
  SmtpCredentials   SmtpCredentials[]
  Activity          Activity[]
  TwoFactorToken    TwoFactorToken[]
  Workspace         Workspace[]
  Notification      Notification[]

  @@unique([id, email])
}

model EmailVerification {
  id String @id @default(uuid())

  // the user that is being verified
  userId String
  user   User   @relation(fields: [userId, email], references: [id, email])

  email String

  // the verification token
  token String @unique

  // the date when the verification was created
  expiresAt DateTime

  @@unique([email, userId])
}

model Session {
  id String @id @default(uuid())

  // the user that is being verified
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // the session token
  token String @unique

  // the date when the session was created
  expiresAt DateTime
}

model Member {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // profile configuration
  profileName String?
  description String?
  image       String? // url to image (hosted on selfmail r2) or undefined for no image

  // permissions
  MemberPermission MemberPermission[]
  roles            Role[]

  createdAt DateTime @default(now())

  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  MemberAddress   MemberAddress[]
  SmtpCredentials SmtpCredentials[]
  Notification    Notification[]

  @@unique(name: "userWorkspaceId", fields: [workspaceId, userId])
}

// permissions

// A role is just a set of editable permissions that can be assigned to users. These roles are editable
// by the owner of the workspace. The owner can create, update, and delete roles, and assign them to users.
model Role {
  id          String  @id @default(uuid())
  name        String
  description String?

  workspaceId    String
  workspace      Workspace        @relation(fields: [workspaceId], references: [id])
  member         Member[]
  RolePermission RolePermission[]
}

model RolePermission {
  roleId String
  role   Role   @relation(fields: [roleId], references: [id])

  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id])

  @@id([roleId, permissionId])
}

model MemberPermission {
  memberId String
  member   Member @relation(fields: [memberId], references: [id])

  permissionName String
  permission     Permission @relation(fields: [permissionName], references: [name])

  givenAt DateTime @default(now())

  @@id([memberId, permissionName])
}

// Permissions are the actual actions that a user can perform in a workspace. These permissions
// are not editable by the owner of the workspace, he can only assign them to roles and users.
model Permission {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  RolePermission    RolePermission[]
  MemberPermissions MemberPermission[]
}

// Workspaces

model Workspace {
  id          String  @id @default(uuid())
  name        String
  description String?
  image       String? // url to image (hosted on selfmail r2) or undefined for no image

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  planId        String
  plan          Plan     @relation(fields: [planId], references: [id])
  planChangedAt DateTime @default(now())

  overlimit   Boolean   @default(false)
  overlimitAt DateTime?

  slug            String            @unique @default(uuid())
  ownerId         String
  owner           User              @relation(fields: [ownerId], references: [id])
  Member          Member[]
  Role            Role[]
  Domain          Domain[]
  SmtpCredentials SmtpCredentials[]
  Activity        Activity[]

  @@index([ownerId])
}

model Plan {
  id String @id @default(uuid())

  name        String  @unique
  description String?

  maxMembers Int // max number of members in the workspace

  // max number of email addresses in the workspace
  maxAddresses             Int    @default(10)
  maxPublicDomainAddresses Int    @default(2) // max number of public domain addresses, for example addresses with the @selfmail.app domain ending
  softBytesMemberLimit     BigInt
  storageBytes             BigInt // storage in bytes

  maxDomains Int // max number of domains in the workspace

  priceEuroCents Int // price in cents for euro

  access Access[]

  Workspace Workspace[]
}

enum Access {
  AI
  API
  SSO
  PrioritySupport
}

model Domain {
  id String @id @default(uuid())

  domain String @unique

  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  verified   Boolean   @default(false)
  verifiedAt DateTime?

  addresses Address[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // ATTENTION: public means, that everybody (EVEN PEOPLE OUTSIDE OF THE WORKSPACE) can create a new address with this domain
  public Boolean @default(false)

  // a verification token must be a txt record for the domain
  // it is used to verify that the user owns the domain
  verificationToken String
}

// addresses
model Address {
  // not the default uuid, because we want to have short ids for the email addresses, in order to short the url (uuid as backup)
  id String @id @default(uuid())

  handle String
  email  String @unique

  // multiple members can access the same address (e.g. shared addresses)
  MemberAddress   MemberAddress[]
  Email           Email[]
  SmtpCredentials SmtpCredentials[]
  Contact         Contact[]

  Domain   Domain? @relation(fields: [domainId], references: [id])
  domainId String?
}

model MemberAddress {
  memberId String
  member   Member @relation(fields: [memberId], references: [id])

  addressId String
  address   Address @relation(fields: [addressId], references: [id])

  @@id([memberId, addressId])
}

model Contact {
  id String @id @default(uuid())

  name        String?
  description String?
  image       String? // url to image (hosted on selfmail r2) or undefined

  blocked Boolean @default(false)

  addressId String
  address   Address @relation(fields: [addressId], references: [id])

  // Expecting addiotional information to be stored as JSON as the following schema:

  /**
   * (pretty weird formatting from vscode and prisma :/ )
   * [
   * {
   * "key": "phone",
   * "value": "+1234567890"
   * },
   * {
   * "key": "address",
   * "value": "123 Main St, Anytown, USA"
   * }
   * ]
   */
  additionalInformation Json[]

  email String
  Email Email[]

  @@unique([email, addressId])
}

model Email {
  id String @id @default(uuid())

  // email metadata
  messageId String? // RFC Message-ID header
  subject   String
  date      DateTime @default(now())

  // size of the bytes to keep in track with the storage
  sizeBytes BigInt

  // read status
  read   Boolean   @default(false)
  readAt DateTime? // when the email was marked as read

  // sender and recipient information
  from    Json // EmailAddress[] from mailparser (name, address)
  to      Json // EmailAddress[] from mailparser (name, address)
  cc      Json? // EmailAddress[] - optional
  bcc     Json? // EmailAddress[] - optional
  replyTo Json? // EmailAddress[] - optional

  // email content
  text String? // plain text version
  html String? // HTML version

  // headers and technical data
  headers Json? // all email headers as JSON

  // attachments information
  attachments Json? // attachment metadata (filename, contentType, size, etc.)

  // security and filtering
  warning     String? // spam/security warnings
  spamScore   Float? // spam score from filtering
  virusStatus String? // virus scan result

  // processing status
  processed       Boolean @default(false)
  processingError String? // any errors during processing

  // raw email data
  rawEmail String? // original EML content (optional, for debugging)

  // the recipient address (our address that received this email)
  addressId String
  address   Address @relation(fields: [addressId], references: [id])

  // contact relationship (sender)
  contact   Contact? @relation(fields: [contactId], references: [id])
  contactId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sort Sort

  @@index([addressId])
  @@index([contactId])
  @@index([date])
  @@index([processed])
  @@index([read])
}

enum Sort {
  normal
  important
  spam
  trash
  sent
}

model SmtpCredentials {
  id String @id @default(uuid())

  title       String
  description String?

  // actual credentials
  username String
  password String

  // Security: Track when password was last viewed
  passwordViewedAt DateTime?

  // created by the user
  memberId String
  member   Member @relation(fields: [memberId], references: [id])

  // the workspace this credentials are used for
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  // the address of the crendentials
  addressId String
  address   Address @relation(fields: [addressId], references: [id])

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  activeUntil DateTime?
  User        User?     @relation(fields: [userId], references: [id])
  userId      String?

  @@unique([username, password])
}

// Activity Log
model Activity {
  id String @id @default(uuid())

  title       String
  description String?
  color       ActivityColor
  type        ActivityType

  // Relations
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId])
  @@index([userId])
  @@index([createdAt])
  @@index([type])
}

enum ActivityColor {
  neutral
  positive
  negative
}

enum ActivityType {
  task
  note
  event
  reminder
}

// Two-Factor Authentication
model TwoFactorToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  expiresAt DateTime

  @@index([userId])
  @@index([token])
}

model Error {
  id String @id @default(uuid())

  message String
  stack   String?
  context Json?

  createdAt DateTime @default(now())
}

model Notification {
  id String @id @default(uuid())

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  memberId String?
  member   Member? @relation(fields: [memberId], references: [id])

  type NotificationType @default(info)

  title   String
  message String

  read   Boolean   @default(false)
  readAt DateTime?

  createdAt DateTime @default(now())
}

model Waitlist {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("waitlist")
}

enum NotificationType {
  info
  warning
  error
}
